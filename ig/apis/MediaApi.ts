/* tslint:disable */
/* eslint-disable */
/**
 * instagrapi-rest
 * RESTful API Service for instagrapi
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  HTTPValidationError,
  Location,
  Media,
  UserShort,
  Usertag,
} from '../models/index';
import {
    HTTPValidationErrorFromJSON,
    HTTPValidationErrorToJSON,
    LocationFromJSON,
    LocationToJSON,
    MediaFromJSON,
    MediaToJSON,
    UserShortFromJSON,
    UserShortToJSON,
    UsertagFromJSON,
    UsertagToJSON,
} from '../models/index';

export interface MediaArchiveMediaArchivePostRequest {
    sessionid: string;
    mediaId: string;
    revert?: boolean;
}

export interface MediaDeleteMediaDeletePostRequest {
    sessionid: string;
    mediaId: string;
}

export interface MediaEditMediaEditPostRequest {
    sessionid: string;
    mediaId: string;
    caption: string;
    title?: string;
    usertags?: Array<Usertag>;
    location?: Location;
}

export interface MediaIdMediaIdGetRequest {
    mediaPk: number;
}

export interface MediaInfoMediaInfoPostRequest {
    sessionid: string;
    pk: number;
    useCache?: boolean;
}

export interface MediaLikeMediaLikePostRequest {
    sessionid: string;
    mediaId: string;
    revert?: boolean;
}

export interface MediaLikersMediaLikersPostRequest {
    sessionid: string;
    mediaId: string;
}

export interface MediaOembedMediaOembedPostRequest {
    sessionid: string;
    url: string;
}

export interface MediaPkFromCodeMediaPkFromCodeGetRequest {
    code: string;
}

export interface MediaPkFromUrlMediaPkFromUrlGetRequest {
    url: string;
}

export interface MediaPkMediaPkGetRequest {
    mediaId: string;
}

export interface MediaSeenMediaSeenPostRequest {
    sessionid: string;
    mediaIds: Array<string>;
    skippedMediaIds?: Array<string>;
}

export interface MediaUnarchiveMediaUnarchivePostRequest {
    sessionid: string;
    mediaId: string;
}

export interface MediaUnlikeMediaUnlikePostRequest {
    sessionid: string;
    mediaId: string;
}

export interface MediaUserMediaUserPostRequest {
    sessionid: string;
    mediaPk: number;
}

export interface UserMediasMediaUserMediasPostRequest {
    sessionid: string;
    userId: number;
    amount?: number;
}

export interface UsertagMediasMediaUsertagMediasPostRequest {
    sessionid: string;
    userId: number;
    amount?: number;
}

/**
 * 
 */
export class MediaApi extends runtime.BaseAPI {

    /**
     * Archive a media     
     * Media Archive
     */
    async mediaArchiveMediaArchivePostRaw(requestParameters: MediaArchiveMediaArchivePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<boolean>> {
        if (requestParameters['sessionid'] == null) {
            throw new runtime.RequiredError(
                'sessionid',
                'Required parameter "sessionid" was null or undefined when calling mediaArchiveMediaArchivePost().'
            );
        }

        if (requestParameters['mediaId'] == null) {
            throw new runtime.RequiredError(
                'mediaId',
                'Required parameter "mediaId" was null or undefined when calling mediaArchiveMediaArchivePost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const consumes: runtime.Consume[] = [
            { contentType: 'application/x-www-form-urlencoded' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['sessionid'] != null) {
            formParams.append('sessionid', requestParameters['sessionid'] as any);
        }

        if (requestParameters['mediaId'] != null) {
            formParams.append('media_id', requestParameters['mediaId'] as any);
        }

        if (requestParameters['revert'] != null) {
            formParams.append('revert', requestParameters['revert'] as any);
        }


        let urlPath = `/media/archive`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<boolean>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Archive a media     
     * Media Archive
     */
    async mediaArchiveMediaArchivePost(requestParameters: MediaArchiveMediaArchivePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<boolean> {
        const response = await this.mediaArchiveMediaArchivePostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete media by Media ID     
     * Media Delete
     */
    async mediaDeleteMediaDeletePostRaw(requestParameters: MediaDeleteMediaDeletePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<boolean>> {
        if (requestParameters['sessionid'] == null) {
            throw new runtime.RequiredError(
                'sessionid',
                'Required parameter "sessionid" was null or undefined when calling mediaDeleteMediaDeletePost().'
            );
        }

        if (requestParameters['mediaId'] == null) {
            throw new runtime.RequiredError(
                'mediaId',
                'Required parameter "mediaId" was null or undefined when calling mediaDeleteMediaDeletePost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const consumes: runtime.Consume[] = [
            { contentType: 'application/x-www-form-urlencoded' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['sessionid'] != null) {
            formParams.append('sessionid', requestParameters['sessionid'] as any);
        }

        if (requestParameters['mediaId'] != null) {
            formParams.append('media_id', requestParameters['mediaId'] as any);
        }


        let urlPath = `/media/delete`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<boolean>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Delete media by Media ID     
     * Media Delete
     */
    async mediaDeleteMediaDeletePost(requestParameters: MediaDeleteMediaDeletePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<boolean> {
        const response = await this.mediaDeleteMediaDeletePostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Edit caption for media     
     * Media Edit
     */
    async mediaEditMediaEditPostRaw(requestParameters: MediaEditMediaEditPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters['sessionid'] == null) {
            throw new runtime.RequiredError(
                'sessionid',
                'Required parameter "sessionid" was null or undefined when calling mediaEditMediaEditPost().'
            );
        }

        if (requestParameters['mediaId'] == null) {
            throw new runtime.RequiredError(
                'mediaId',
                'Required parameter "mediaId" was null or undefined when calling mediaEditMediaEditPost().'
            );
        }

        if (requestParameters['caption'] == null) {
            throw new runtime.RequiredError(
                'caption',
                'Required parameter "caption" was null or undefined when calling mediaEditMediaEditPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const consumes: runtime.Consume[] = [
            { contentType: 'application/x-www-form-urlencoded' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['sessionid'] != null) {
            formParams.append('sessionid', requestParameters['sessionid'] as any);
        }

        if (requestParameters['mediaId'] != null) {
            formParams.append('media_id', requestParameters['mediaId'] as any);
        }

        if (requestParameters['caption'] != null) {
            formParams.append('caption', requestParameters['caption'] as any);
        }

        if (requestParameters['title'] != null) {
            formParams.append('title', requestParameters['title'] as any);
        }

        if (requestParameters['usertags'] != null) {
            formParams.append('usertags', requestParameters['usertags']!.join(runtime.COLLECTION_FORMATS["csv"]));
        }

        if (requestParameters['location'] != null) {
            formParams.append('location', new Blob([JSON.stringify(objectToJSON(requestParameters['location']))], { type: "application/json", }));
                    }


        let urlPath = `/media/edit`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Edit caption for media     
     * Media Edit
     */
    async mediaEditMediaEditPost(requestParameters: MediaEditMediaEditPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.mediaEditMediaEditPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get full media id     
     * Media Id
     */
    async mediaIdMediaIdGetRaw(requestParameters: MediaIdMediaIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['mediaPk'] == null) {
            throw new runtime.RequiredError(
                'mediaPk',
                'Required parameter "mediaPk" was null or undefined when calling mediaIdMediaIdGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['mediaPk'] != null) {
            queryParameters['media_pk'] = requestParameters['mediaPk'];
        }

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/media/id`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Get full media id     
     * Media Id
     */
    async mediaIdMediaIdGet(requestParameters: MediaIdMediaIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.mediaIdMediaIdGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get media info by pk     
     * Media Info
     */
    async mediaInfoMediaInfoPostRaw(requestParameters: MediaInfoMediaInfoPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Media>> {
        if (requestParameters['sessionid'] == null) {
            throw new runtime.RequiredError(
                'sessionid',
                'Required parameter "sessionid" was null or undefined when calling mediaInfoMediaInfoPost().'
            );
        }

        if (requestParameters['pk'] == null) {
            throw new runtime.RequiredError(
                'pk',
                'Required parameter "pk" was null or undefined when calling mediaInfoMediaInfoPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const consumes: runtime.Consume[] = [
            { contentType: 'application/x-www-form-urlencoded' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['sessionid'] != null) {
            formParams.append('sessionid', requestParameters['sessionid'] as any);
        }

        if (requestParameters['pk'] != null) {
            formParams.append('pk', requestParameters['pk'] as any);
        }

        if (requestParameters['useCache'] != null) {
            formParams.append('use_cache', requestParameters['useCache'] as any);
        }


        let urlPath = `/media/info`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MediaFromJSON(jsonValue));
    }

    /**
     * Get media info by pk     
     * Media Info
     */
    async mediaInfoMediaInfoPost(requestParameters: MediaInfoMediaInfoPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Media> {
        const response = await this.mediaInfoMediaInfoPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Like a media     
     * Media Like
     */
    async mediaLikeMediaLikePostRaw(requestParameters: MediaLikeMediaLikePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<boolean>> {
        if (requestParameters['sessionid'] == null) {
            throw new runtime.RequiredError(
                'sessionid',
                'Required parameter "sessionid" was null or undefined when calling mediaLikeMediaLikePost().'
            );
        }

        if (requestParameters['mediaId'] == null) {
            throw new runtime.RequiredError(
                'mediaId',
                'Required parameter "mediaId" was null or undefined when calling mediaLikeMediaLikePost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const consumes: runtime.Consume[] = [
            { contentType: 'application/x-www-form-urlencoded' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['sessionid'] != null) {
            formParams.append('sessionid', requestParameters['sessionid'] as any);
        }

        if (requestParameters['mediaId'] != null) {
            formParams.append('media_id', requestParameters['mediaId'] as any);
        }

        if (requestParameters['revert'] != null) {
            formParams.append('revert', requestParameters['revert'] as any);
        }


        let urlPath = `/media/like`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<boolean>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Like a media     
     * Media Like
     */
    async mediaLikeMediaLikePost(requestParameters: MediaLikeMediaLikePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<boolean> {
        const response = await this.mediaLikeMediaLikePostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get user\'s likers     
     * Media Likers
     */
    async mediaLikersMediaLikersPostRaw(requestParameters: MediaLikersMediaLikersPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<UserShort>>> {
        if (requestParameters['sessionid'] == null) {
            throw new runtime.RequiredError(
                'sessionid',
                'Required parameter "sessionid" was null or undefined when calling mediaLikersMediaLikersPost().'
            );
        }

        if (requestParameters['mediaId'] == null) {
            throw new runtime.RequiredError(
                'mediaId',
                'Required parameter "mediaId" was null or undefined when calling mediaLikersMediaLikersPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const consumes: runtime.Consume[] = [
            { contentType: 'application/x-www-form-urlencoded' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['sessionid'] != null) {
            formParams.append('sessionid', requestParameters['sessionid'] as any);
        }

        if (requestParameters['mediaId'] != null) {
            formParams.append('media_id', requestParameters['mediaId'] as any);
        }


        let urlPath = `/media/likers`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(UserShortFromJSON));
    }

    /**
     * Get user\'s likers     
     * Media Likers
     */
    async mediaLikersMediaLikersPost(requestParameters: MediaLikersMediaLikersPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<UserShort>> {
        const response = await this.mediaLikersMediaLikersPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Return info about media and user from post URL     
     * Media Oembed
     */
    async mediaOembedMediaOembedPostRaw(requestParameters: MediaOembedMediaOembedPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters['sessionid'] == null) {
            throw new runtime.RequiredError(
                'sessionid',
                'Required parameter "sessionid" was null or undefined when calling mediaOembedMediaOembedPost().'
            );
        }

        if (requestParameters['url'] == null) {
            throw new runtime.RequiredError(
                'url',
                'Required parameter "url" was null or undefined when calling mediaOembedMediaOembedPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const consumes: runtime.Consume[] = [
            { contentType: 'application/x-www-form-urlencoded' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['sessionid'] != null) {
            formParams.append('sessionid', requestParameters['sessionid'] as any);
        }

        if (requestParameters['url'] != null) {
            formParams.append('url', requestParameters['url'] as any);
        }


        let urlPath = `/media/oembed`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Return info about media and user from post URL     
     * Media Oembed
     */
    async mediaOembedMediaOembedPost(requestParameters: MediaOembedMediaOembedPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.mediaOembedMediaOembedPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get media pk from code     
     * Media Pk From Code
     */
    async mediaPkFromCodeMediaPkFromCodeGetRaw(requestParameters: MediaPkFromCodeMediaPkFromCodeGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['code'] == null) {
            throw new runtime.RequiredError(
                'code',
                'Required parameter "code" was null or undefined when calling mediaPkFromCodeMediaPkFromCodeGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['code'] != null) {
            queryParameters['code'] = requestParameters['code'];
        }

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/media/pk_from_code`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Get media pk from code     
     * Media Pk From Code
     */
    async mediaPkFromCodeMediaPkFromCodeGet(requestParameters: MediaPkFromCodeMediaPkFromCodeGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.mediaPkFromCodeMediaPkFromCodeGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get Media PK from URL     
     * Media Pk From Url
     */
    async mediaPkFromUrlMediaPkFromUrlGetRaw(requestParameters: MediaPkFromUrlMediaPkFromUrlGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['url'] == null) {
            throw new runtime.RequiredError(
                'url',
                'Required parameter "url" was null or undefined when calling mediaPkFromUrlMediaPkFromUrlGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['url'] != null) {
            queryParameters['url'] = requestParameters['url'];
        }

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/media/pk_from_url`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Get Media PK from URL     
     * Media Pk From Url
     */
    async mediaPkFromUrlMediaPkFromUrlGet(requestParameters: MediaPkFromUrlMediaPkFromUrlGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.mediaPkFromUrlMediaPkFromUrlGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get short media id     
     * Media Pk
     */
    async mediaPkMediaPkGetRaw(requestParameters: MediaPkMediaPkGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['mediaId'] == null) {
            throw new runtime.RequiredError(
                'mediaId',
                'Required parameter "mediaId" was null or undefined when calling mediaPkMediaPkGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['mediaId'] != null) {
            queryParameters['media_id'] = requestParameters['mediaId'];
        }

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/media/pk`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Get short media id     
     * Media Pk
     */
    async mediaPkMediaPkGet(requestParameters: MediaPkMediaPkGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.mediaPkMediaPkGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Mark a media as seen     
     * Media Seen
     */
    async mediaSeenMediaSeenPostRaw(requestParameters: MediaSeenMediaSeenPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<boolean>> {
        if (requestParameters['sessionid'] == null) {
            throw new runtime.RequiredError(
                'sessionid',
                'Required parameter "sessionid" was null or undefined when calling mediaSeenMediaSeenPost().'
            );
        }

        if (requestParameters['mediaIds'] == null) {
            throw new runtime.RequiredError(
                'mediaIds',
                'Required parameter "mediaIds" was null or undefined when calling mediaSeenMediaSeenPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const consumes: runtime.Consume[] = [
            { contentType: 'application/x-www-form-urlencoded' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['sessionid'] != null) {
            formParams.append('sessionid', requestParameters['sessionid'] as any);
        }

        if (requestParameters['mediaIds'] != null) {
            formParams.append('media_ids', requestParameters['mediaIds']!.join(runtime.COLLECTION_FORMATS["csv"]));
        }

        if (requestParameters['skippedMediaIds'] != null) {
            formParams.append('skipped_media_ids', requestParameters['skippedMediaIds']!.join(runtime.COLLECTION_FORMATS["csv"]));
        }


        let urlPath = `/media/seen`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<boolean>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Mark a media as seen     
     * Media Seen
     */
    async mediaSeenMediaSeenPost(requestParameters: MediaSeenMediaSeenPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<boolean> {
        const response = await this.mediaSeenMediaSeenPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Unarchive a media     
     * Media Unarchive
     */
    async mediaUnarchiveMediaUnarchivePostRaw(requestParameters: MediaUnarchiveMediaUnarchivePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<boolean>> {
        if (requestParameters['sessionid'] == null) {
            throw new runtime.RequiredError(
                'sessionid',
                'Required parameter "sessionid" was null or undefined when calling mediaUnarchiveMediaUnarchivePost().'
            );
        }

        if (requestParameters['mediaId'] == null) {
            throw new runtime.RequiredError(
                'mediaId',
                'Required parameter "mediaId" was null or undefined when calling mediaUnarchiveMediaUnarchivePost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const consumes: runtime.Consume[] = [
            { contentType: 'application/x-www-form-urlencoded' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['sessionid'] != null) {
            formParams.append('sessionid', requestParameters['sessionid'] as any);
        }

        if (requestParameters['mediaId'] != null) {
            formParams.append('media_id', requestParameters['mediaId'] as any);
        }


        let urlPath = `/media/unarchive`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<boolean>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Unarchive a media     
     * Media Unarchive
     */
    async mediaUnarchiveMediaUnarchivePost(requestParameters: MediaUnarchiveMediaUnarchivePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<boolean> {
        const response = await this.mediaUnarchiveMediaUnarchivePostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Unlike a media     
     * Media Unlike
     */
    async mediaUnlikeMediaUnlikePostRaw(requestParameters: MediaUnlikeMediaUnlikePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<boolean>> {
        if (requestParameters['sessionid'] == null) {
            throw new runtime.RequiredError(
                'sessionid',
                'Required parameter "sessionid" was null or undefined when calling mediaUnlikeMediaUnlikePost().'
            );
        }

        if (requestParameters['mediaId'] == null) {
            throw new runtime.RequiredError(
                'mediaId',
                'Required parameter "mediaId" was null or undefined when calling mediaUnlikeMediaUnlikePost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const consumes: runtime.Consume[] = [
            { contentType: 'application/x-www-form-urlencoded' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['sessionid'] != null) {
            formParams.append('sessionid', requestParameters['sessionid'] as any);
        }

        if (requestParameters['mediaId'] != null) {
            formParams.append('media_id', requestParameters['mediaId'] as any);
        }


        let urlPath = `/media/unlike`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<boolean>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Unlike a media     
     * Media Unlike
     */
    async mediaUnlikeMediaUnlikePost(requestParameters: MediaUnlikeMediaUnlikePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<boolean> {
        const response = await this.mediaUnlikeMediaUnlikePostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get author of the media     
     * Media User
     */
    async mediaUserMediaUserPostRaw(requestParameters: MediaUserMediaUserPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserShort>> {
        if (requestParameters['sessionid'] == null) {
            throw new runtime.RequiredError(
                'sessionid',
                'Required parameter "sessionid" was null or undefined when calling mediaUserMediaUserPost().'
            );
        }

        if (requestParameters['mediaPk'] == null) {
            throw new runtime.RequiredError(
                'mediaPk',
                'Required parameter "mediaPk" was null or undefined when calling mediaUserMediaUserPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const consumes: runtime.Consume[] = [
            { contentType: 'application/x-www-form-urlencoded' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['sessionid'] != null) {
            formParams.append('sessionid', requestParameters['sessionid'] as any);
        }

        if (requestParameters['mediaPk'] != null) {
            formParams.append('media_pk', requestParameters['mediaPk'] as any);
        }


        let urlPath = `/media/user`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserShortFromJSON(jsonValue));
    }

    /**
     * Get author of the media     
     * Media User
     */
    async mediaUserMediaUserPost(requestParameters: MediaUserMediaUserPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserShort> {
        const response = await this.mediaUserMediaUserPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a user\'s media     
     * User Medias
     */
    async userMediasMediaUserMediasPostRaw(requestParameters: UserMediasMediaUserMediasPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Media>>> {
        if (requestParameters['sessionid'] == null) {
            throw new runtime.RequiredError(
                'sessionid',
                'Required parameter "sessionid" was null or undefined when calling userMediasMediaUserMediasPost().'
            );
        }

        if (requestParameters['userId'] == null) {
            throw new runtime.RequiredError(
                'userId',
                'Required parameter "userId" was null or undefined when calling userMediasMediaUserMediasPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const consumes: runtime.Consume[] = [
            { contentType: 'application/x-www-form-urlencoded' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['sessionid'] != null) {
            formParams.append('sessionid', requestParameters['sessionid'] as any);
        }

        if (requestParameters['userId'] != null) {
            formParams.append('user_id', requestParameters['userId'] as any);
        }

        if (requestParameters['amount'] != null) {
            formParams.append('amount', requestParameters['amount'] as any);
        }


        let urlPath = `/media/user_medias`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(MediaFromJSON));
    }

    /**
     * Get a user\'s media     
     * User Medias
     */
    async userMediasMediaUserMediasPost(requestParameters: UserMediasMediaUserMediasPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Media>> {
        const response = await this.userMediasMediaUserMediasPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get medias where a user is tagged     
     * Usertag Medias
     */
    async usertagMediasMediaUsertagMediasPostRaw(requestParameters: UsertagMediasMediaUsertagMediasPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Media>>> {
        if (requestParameters['sessionid'] == null) {
            throw new runtime.RequiredError(
                'sessionid',
                'Required parameter "sessionid" was null or undefined when calling usertagMediasMediaUsertagMediasPost().'
            );
        }

        if (requestParameters['userId'] == null) {
            throw new runtime.RequiredError(
                'userId',
                'Required parameter "userId" was null or undefined when calling usertagMediasMediaUsertagMediasPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const consumes: runtime.Consume[] = [
            { contentType: 'application/x-www-form-urlencoded' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['sessionid'] != null) {
            formParams.append('sessionid', requestParameters['sessionid'] as any);
        }

        if (requestParameters['userId'] != null) {
            formParams.append('user_id', requestParameters['userId'] as any);
        }

        if (requestParameters['amount'] != null) {
            formParams.append('amount', requestParameters['amount'] as any);
        }


        let urlPath = `/media/usertag_medias`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(MediaFromJSON));
    }

    /**
     * Get medias where a user is tagged     
     * Usertag Medias
     */
    async usertagMediasMediaUsertagMediasPost(requestParameters: UsertagMediasMediaUsertagMediasPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Media>> {
        const response = await this.usertagMediasMediaUsertagMediasPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
